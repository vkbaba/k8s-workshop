---
weight: 3
title: "イメージ"
---

## イメージとは
コンテナイメージから実行中のコンテナを作成しました。使用したコンテナイメージは、イメージレジストリから取得したものです。一般的に使用されているソフトウェアアプリケーション用のコンテナイメージは数多くありますが、自分のアプリケーション用にコンテナイメージを作成することの方が多いでしょう。

コンテナイメージとは、アプリケーションを配布するためのパッケージメカニズムであり、アプリケーションの実行に必要なアプリケーションソフトウェア、オペレーティングシステムファイル、ライブラリ、その他のソフトウェアを含んでいると説明しました。

その意味では、コンテナイメージは、ファイルシステムを構成するために解凍されるtarballやzipファイルのようなものだと言えます。しかし、それよりも少し複雑です。

コンテナイメージは、すべての必要なファイルを含む単一のパッケージではなく、パッケージの集合体であり、それぞれがコンテナイメージの1つのレイヤーのファイルを含んでいます。

コンテナイメージのレイヤー

各コンテナイメージは、まずベースレイヤーから始まります。ベースレイヤーには、通常、ベースとなるOSファイル、アプリケーション、ライブラリがすべて含まれています。

その上にさらにレイヤーを追加していきます。各レイヤーでは、ファイルを追加したり、既存のファイルを変更したり、ファイルを削除したりします。

既存のファイルを修正したり削除したりする場合、変更されるのは下位レイヤーのオリジナルファイルではありません。修正の場合は、変更を加えたファイルの新しいコピーが新しいレイヤーに存在し、下のレイヤーのオリジナルはそのまま存在します。ファイルの削除の場合は、そのレイヤーでファイルが削除されたことがレイヤーのメタデータに記録され、オリジナルは下のレイヤーに残っています。

このように変更や削除が行われるのは、各レイヤーが不変であるためです。変更を加えるには、新しいレイヤーを作成するしかありません。

コンテナイメージを使用してコンテナを作成する場合は、コンテナイメージの各レイヤーを重ね合わせてレイヤーを合成して表示する特殊なファイルシステムが使用されます。

読み取り専用ファイルシステム

この最終的なコンポジットビューは、それ自体が読み取り専用である。コンテナ内のファイルに加えられた変更は、コンテナの寿命まで存在する別のレイヤに存在することになる。

コンテナのイメージフォーマットの実際の仕様は、OCI Image Format Specification で定義されています。また、コンテナ内でアプリケーションを実行するために、イメージをどのようにアンパックし、解釈し、使用するかは、OCI Runtime Specificationで定義されています。どちらの仕様も、Linux FoundationがスポンサーとなっているOpen Container Initiative のガバナンスの下で管理されています。

## イメージのビルド
コンテナイメージを構築するには、主に3つの方法があります。

- 既存のイメージを使ってコンテナを起動し、コンテナに変更を加え、その結果を新しいコンテナイメージとして保存することで、インタラクティブにイメージを構築する方法。

- 入力ファイルに記述されたスクリプトを使って、バッチプロセスでコンテナイメージを作成する。典型的な例としては、Dockerfileを使用してコンテナイメージを作成することが挙げられる。

- tarballからファイルシステムのコピーをインポートしてコンテナイメージを作成する。

このワークショップでは、典型的な手法である2 つめのDockerfile を用いた方法を見ていきます。

## Dockerfile

~/greeting-v1 に移動します。
```shell
cd ~/exercises/greeting-v1
```

Dockerfileは、新しいコンテナイメージを作成するベースイメージの詳細と、それを作成するための手順を定義しています。Dockerfile の内容を表示します。
```shell
cat Dockerfile
```
```dockerfile
FROM busybox:latest

COPY hello goodbye /

CMD [ "/hello" ]
```
DockerfileのFROM命令は、ベースイメージの名前を指定します。

COPY命令は、ローカルディレクトリからイメージにファイルをコピーするために使用されます。

CMD命令は、コンテナイメージが明示的なコマンドを指定せずに実行された場合に実行されるコマンドを設定するために使用します。

Dockerfileの命令を使ってコンテナイメージを構築するには、次のように実行します。
```shell
docker build -t greeting .
```
-t でイメージの名前を指定し、"." はDockerfile のパスを指定しています。

コンテナイメージのレイヤーを見るには、次のように実行します。

```shell
docker history greeting
```

以下のような出力が得られるはずです。
```shell
IMAGE               CREATED             CREATED BY                                      SIZE
COMMENT
0ac1216f0e3f        4 seconds ago       /bin/sh -c #(nop)  CMD ["/hello"]               0B
aeea9801fb6a        4 seconds ago       /bin/sh -c #(nop) COPY multi:03e82c91fe5fcae…   50B
be5888e67be6        5 days ago          /bin/sh -c #(nop)  CMD ["sh"]                   0B
<missing>           5 days ago          /bin/sh -c #(nop) ADD file:09a89925137e1b768…   1.22MB
```

コンテナイメージの中に、DockerfileからのCOPYとCMDの文のためのレイヤーが作成されていることがわかります。

コンテナイメージを実行するには、次のように実行します。
```shell

docker run --rm greeting
```
あるいは、別のコマンドを実行するには、次のようにします。
```shell
docker run --rm greeting /goodbye
```
Dockerfileで使用できる命令の完全なリストについては、Dockerfileリファレンスをご覧ください。

## イメージの共有
独自のカスタムコンテナイメージを作成した後、それを別のホストシステムで実行する必要がある場合には、そのイメージを配布する方法が必要になります。

コンテナイメージを配布する一般的な方法は、イメージレジストリにプッシュすることです。イメージレジストリにプッシュされたコンテナイメージは、他のホストにプルダウンして実行することができます。このためには、Docker Hub や Quay.io などのパブリックなイメージレジストリを使用するか、独自のプライベートなイメージレジストリを使用することができます。

イメージをイメージレジストリにプッシュするには、まずそのイメージレジストリーにログインする必要があります。

このワークショップの環境では、あなたはすでにログインしている自分のプライベートイメージレジストリを持っています。もし自分でやるのであれば、docker loginコマンドを使ってイメージレジストリの場所を指定します。すると、ログイン情報の入力を求められます。

次に、コンテナイメージにイメージレジストリの名前を組み込んだ名前をタグ付けする必要があります。

この時点でのイメージの名前はgreetingなので、イメージレジストリの名前を含む名前をタグ付けするには、次のように実行する必要があります。

```shell
NS=$(kubectl config view -o jsonpath='{.contexts[].context.namespace}')
```
{{< hint info >}}
上記コマンドはハンズオンのセッションによって異なるレジストリの名前の一部を取得しています。
{{< /hint >}}

```shell
docker tag greeting:latest ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest
```
イメージをイメージレジストリにプッシュするには、次のように実行します。
```shell
docker push ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest
```
イメージレジストリへの適切なアクセス権を持つ人は、次のように実行して、イメージを別のホストでプルすることができます。
```shell
docker pull ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest
```