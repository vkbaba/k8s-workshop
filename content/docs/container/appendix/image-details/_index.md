---
weight: 1
title: "イメージの詳細"
---

## イメージの詳細
その意味では、コンテナイメージは、ファイルシステムを構成するために解凍されるtarballやzipファイルのようなものだと言えます。しかし、それよりも少し複雑です。

コンテナイメージは、すべての必要なファイルを含む単一のパッケージではなく、パッケージの集合体であり、それぞれがコンテナイメージの1つのレイヤーのファイルを含んでいます。

コンテナイメージのレイヤー

各コンテナイメージは、まずベースレイヤーから始まります。ベースレイヤーには、通常、ベースとなるOSファイル、アプリケーション、ライブラリがすべて含まれています。

その上にさらにレイヤーを追加していきます。各レイヤーでは、ファイルを追加したり、既存のファイルを変更したり、ファイルを削除したりします。

既存のファイルを修正したり削除したりする場合、変更されるのは下位レイヤーのオリジナルファイルではありません。修正の場合は、変更を加えたファイルの新しいコピーが新しいレイヤーに存在し、下のレイヤーのオリジナルはそのまま存在します。ファイルの削除の場合は、そのレイヤーでファイルが削除されたことがレイヤーのメタデータに記録され、オリジナルは下のレイヤーに残っています。

このように変更や削除が行われるのは、各レイヤーが不変であるためです。変更を加えるには、新しいレイヤーを作成するしかありません。

コンテナイメージを使用してコンテナを作成する場合は、コンテナイメージの各レイヤーを重ね合わせてレイヤーを合成して表示する特殊なファイルシステムが使用されます。

読み取り専用ファイルシステム

この最終的なコンポジットビューは、それ自体が読み取り専用である。コンテナ内のファイルに加えられた変更は、コンテナの寿命まで存在する別のレイヤに存在することになる。

コンテナのイメージフォーマットの実際の仕様は、OCI Image Format Specification で定義されています。また、コンテナ内でアプリケーションを実行するために、イメージをどのようにアンパックし、解釈し、使用するかは、OCI Runtime Specificationで定義されています。どちらの仕様も、Linux FoundationがスポンサーとなっているOpen Container Initiative のガバナンスの下で管理されています。

コンテナイメージのレイヤーを見るには、次のように実行します。

```shell
docker history greeting
```

以下のような出力が得られるはずです。

    IMAGE               CREATED             CREATED BY                                      SIZE
    COMMENT
    0ac1216f0e3f        4 seconds ago       /bin/sh -c #(nop)  CMD ["/hello"]               0B
    aeea9801fb6a        4 seconds ago       /bin/sh -c #(nop) COPY multi:03e82c91fe5fcae…   50B
    be5888e67be6        5 days ago          /bin/sh -c #(nop)  CMD ["sh"]                   0B
    <missing>           5 days ago          /bin/sh -c #(nop) ADD file:09a89925137e1b768…   1.22MB


コンテナイメージの中に、DockerfileからのCOPY とCMD の文のためのレイヤーが作成されていることがわかります。
