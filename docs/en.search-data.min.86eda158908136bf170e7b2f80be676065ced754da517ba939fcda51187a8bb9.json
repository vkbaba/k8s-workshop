[{"id":0,"href":"/k8s-workshop/docs/container/appendix/image-details/","title":"イメージの詳細","section":"コンテナハンズオン","content":"イメージの詳細 #  "},{"id":1,"href":"/k8s-workshop/docs/container/","title":"コンテナハンズオン","section":"Docs","content":"ハンズオンの概要 #  コンテナは、OSレベルの仮想化の軽量な形態です。これにより、完全なOSを実行することなく、一連のアプリケーションプロセスを独自の分離された環境で実行することができます。\nこのハンズオンでは、コンテナイメージを構築して実行する方法の基本を学びます。使用するツールはdockerです。\n使用するラボ #   "},{"id":2,"href":"/k8s-workshop/docs/kubernetes/resource/","title":"リソースの詳細","section":"Kubernetes ハンズオン","content":"リソース #  "},{"id":3,"href":"/k8s-workshop/docs/container/basic/","title":"基本操作","section":"コンテナハンズオン","content":"コンテナの起動 #  dockerを使ってアプリケーションをコンテナ内で起動するには、コンテナイメージが必要です。コンテナイメージは、アプリケーションを配布するためのパッケージメカニズムとして機能し、アプリケーションソフトウェア、オペレーティングシステムファイル、ライブラリ、その他アプリケーションの実行に必要なソフトウェアが含まれています。\n アプリケーション用のあらかじめ構築されたコンテナイメージや、独自のコンテナイメージを構築するためのベースとなるコンテナイメージは、イメージレジストリを使用して配布されます。\nイメージレジストリは、Docker Hub\r のようなホスト型サービスが存在します。また、Github\r やGitLab\rのようなGitリポジトリのホスティングサービスでも、コンテナイメージのホスティングと配布をサポートしています。\ndocker runを使ってイメージレジストリから既存のコンテナイメージをプルダウンして実行するには以下を実行します。\ndocker run docker.io/busybox:latest date アウトプットは以下のようになります。\nUnable to find image 'busybox:latest' locally latest: Pulling from library/busybox e2334dd9fee4: Pull complete Digest: sha256:a8cf7ff6367c2afa2a90acd081b484cbded349a7076e7bdf37a05279f276bc12 Status: Downloaded newer image for busybox:latest Mon Apr 20 00:11:37 UTC 2020  このコマンドは、イメージをローカル環境にプルダウンするために行われた手順の詳細をログに記録します。この処理が完了すると、コンテナイメージからコンテナが起動され、コマンドラインで指定されたdateコマンドがコンテナ内で実行されます。dateコマンドはすぐに終了するので、コンテナはそのままシャットダウンされます。\n今回使用したコンテナイメージは、busyboxというものです。これは、非常にミニマルなUnixライクのコンテナイメージで、よく利用されるコマンドを詰め込んでいる便利なイメージです。最新バージョンのコンテナイメージを使用し（:latest）、Docker Hubのイメージレジストリ（docker.io）から取得するように指定しました。\nこのコマンドをもう1回実行してみてください。\ndocker run docker.io/busybox:latest date dateコマンドがすぐに実行され、コンテナイメージを最初にプルダウンする必要があるという詳細情報は記録されないことがわかります。これは、コンテナイメージがローカル環境にキャッシュされ、次回以降の実行時に使用されるからです。\nどのようなコンテナイメージがローカル環境にプルダウンされたかは、次のように実行することで確認できます。\ndocker images アウトプットは以下のようになります。\nREPOSITORY TAG IMAGE ID CREATED SIZE busybox latest be5888e67be6 5 days ago 1.22MB  必要であれば、docker runはコンテナイメージを最初に必要とされるときにプルダウンします。実行される前にイメージをプルダウンしたい場合は、docker pullコマンドを使用することができます。\ndocker pull docker.io/busybox:latest ターミナルの操作 #  先ほどはbusybox コンテナイメージから起動したコンテナ内で date コマンドを実行しました。コンテナイメージに含まれている任意のアプリケーションを実行することができます。\nコンテナを作成して、その中でコマンドを実行するために対話したい場合は、対話型シェルを実行します。\ndocker run -it busybox sh 対話型端末を必要とするコマンドを実行する場合は、docker runに-itオプションを指定する必要があります。これにより、ターミナルが確保され、stdinが入力可能な状態に保たれます。\n参考 : https://ohbarye.hatenablog.jp/entry/2019/05/05/learn-tty-with-docker\r\n「コンテナの中に入って何か操作をしたい場合 = -it」 と最初は覚えてしまいましょう。  また、今回はコンテナイメージの名前をbusyboxと略しています。バージョンタグが指定されていない場合は latest が使用されます。イメージレジストリのホストが指定されていない場合は、dockerのグローバル設定で定義されているデフォルトのイメージレジストリが検索されます。すでにDocker Hubからbusybox:latestのイメージを取り出しているので、それがマッチします。\nコンテナ内で実行されているプロセスの一覧を見るには、次のように実行します。\nps 以下のような出力が表示されるはずです。\npid user time command 1 root 0:00 sh 8 root 0:00 ps  コンテナのコンテキスト内で起動したプロセスのみが表示されます。下層のコンテナホスト（例えばコンテナを実行している仮想マシン）で実行されているプロセスは表示されません。\n実行中のコンテナの一覧を表示するには、コンテナホスト上で実行します。ターミナル2 でdocker ps コマンドを試してみてください（ターミナル1 はコンテナの中に入ったままです）。\nexit docker ps 上記で起動したコンテナが対話型シェルで実行されているのが確認できるはずです。\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae576793e3e9 busybox \u0026quot;sh\u0026quot; 32 seconds ago Up 31 seconds recursing_leavitt  コンテナホストから既存のコンテナにアクセスし、その中でコマンドを実行するには、docker execコマンドを使用します。docker runと同様に、インタラクティブなターミナルを必要とするコマンドを実行する場合は、-itオプションを使用します。\ndocker execを実行する際には、アクセスしたいコンテナのIDを指定する必要があります。最後に起動したコンテナのコンテナIDを表示するには、次のコマンドを実行します。\ndocker ps -ql では、起動中のコンテナの中にexec コマンドで入ってみましょう。\ndocker exec -it `docker ps -ql` sh 再度 ps を実行します。\nps これで、2つのシェルプロセスが実行されていることが確認できます。\n1つ目の対話型ターミナルで次のように実行して終了します。\nexit このプロセスはコンテナ内で実行されているメインプロセスであり、プロセスIDは1であるため、コンテナがシャットダウンされ、2つ目の対話型端末のセッションも閉じられます。\nコンテナの停止 #  コンテナがシャットダウンされると、アプリケーションプロセスはなくなりますが、コンテナの状態のコピーは保持されます。停止したコンテナを含むすべてのコンテナの一覧は、次のように実行することで確認できます。\ndocker ps -a いくつものコンテナを起動しているので、停止しているコンテナが複数表示されているはずです。\nONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae576793e3e9 busybox \u0026quot;sh\u0026quot; About a minute ago Exited (0) 16 seconds ago recursing_leavitt e894e7d5790f busybox:latest \u0026quot;date\u0026quot; 3 minutes ago Exited (0) 3 minutes ago heuristic_bassi 9d1706a4b51f busybox:latest \u0026quot;date\u0026quot; 3 minutes ago Exited (0) 3 minutes ago inspiring_banzai  コンテナからの出力はログファイルにも取り込まれます。コンテナIDを引数にしてdocker logsコマンドを実行すると、実行中または停止中のコンテナのログファイルを見ることができます。\ndocker logs `docker ps -ql` コンテナのログファイルに加えて、コンテナ内からファイルシステムに加えられた変更のコピーも保存されるため、停止中のコンテナからファイルをコピーしたり、停止中のコンテナから新しいコンテナイメージを作成したりすることもできます。 補足 どこにあるか   停止したコンテナにはいくつかの用途がありますが、スペースを消費しますので、停止したコンテナを削除することが重要です。そうしないと、最終的にはディスクスペースが足りなくなってしまいます。\n停止したコンテナを1つだけ削除するには、コンテナIDを引数にしてdocker rmを使用します。\ndocker rm `docker ps -ql` これで、停止していた2つのコンテナだけが残るはずです。\ndocker ps -a 停止しているコンテナをすべて削除するには、次のように実行します。\ndocker rm $(docker ps -aq) docker ps -aは停止中のコンテナだけでなく、稼働中のコンテナも反応しますが、docker rmコマンドは停止中のコンテナのみを削除します。\nこれでコンテナは残っていないはずです。\n停止したコンテナをシャットダウンした後に操作する必要がないことがわかっている場合は、docker runの実行時に--rmオプションを使用できます。\ndocker run --rm busybox date このオプションを使用すると、停止したコンテナは自動的に削除されます。 検証目的においては常に--rm オプションをつけるよう意識しておくとディスクスペースの節約につながります。\n "},{"id":4,"href":"/k8s-workshop/docs/kubernetes/basic/","title":"基本操作","section":"Kubernetes ハンズオン","content":"クラスタへのアクセス #  これから行うハンズオンでは、kubectl CLIを使用してKubernetesとやり取りします。このCLI は、ワークショップ環境の「ターミナル」タブからアクセスできるインタラクティブなターミナルセッションで提供されます。ご自身のコンピュータに何かをインストールする必要はありません。ここでは、Webブラウザを使ってすべての操作を行うことになります。使用するKubernetesクラスタにはすでに接続されているので、ログインする必要はありません。\nワークショップ環境では、KubernetesクラスタをWebベースで確認することもできます。これは、ワークショップ環境の「コンソール」タブから利用できます。これは、ハンズオンで行うことの結果を視覚的に確認するために含まれていますが、ハンズオンはこれに依存しません。\nハンズオンを続ける前に、kubectlコマンドが実行され、ワークショップ環境も機能していることを確認します。これを行うには、次のように実行します。\nkubectl version 実行すると、次のような出力が表示されます。\nClient Version: version.Info{Major:\u0026quot;1\u0026quot;, Minor:\u0026quot;17\u0026quot;, GitVersion:\u0026quot;v1.17.0\u0026quot;, GitCommit:\u0026quot;70132b0f130acc0bed193d9\rba59dd186f0e634cf\u0026quot;, GitTreeState:\u0026quot;clean\u0026quot;, BuildDate:\u0026quot;2019-12-07T21:20:10Z\u0026quot;, GoVersion:\u0026quot;go1.13.4\u0026quot;, Compiler:\u0026quot;\rgc\u0026quot;, Platform:\u0026quot;linux/amd64\u0026quot;}\rServer Version: version.Info{Major:\u0026quot;1\u0026quot;, Minor:\u0026quot;17\u0026quot;, GitVersion:\u0026quot;v1.17.0\u0026quot;, GitCommit:\u0026quot;70132b0f130acc0bed193d9\rba59dd186f0e634cf\u0026quot;, GitTreeState:\u0026quot;clean\u0026quot;, BuildDate:\u0026quot;2019-12-07T21:12:17Z\u0026quot;, GoVersion:\u0026quot;go1.13.4\u0026quot;, Compiler:\u0026quot;\rgc\u0026quot;, Platform:\u0026quot;linux/amd64\u0026quot;}\r 使用しているKubernetesのバージョンは、ここで示したバージョンと異なる場合があります。\nアプリケーションのデプロイ #  さて、Kubernetesクラスタへのアクセスが正常に行われていることを確認したら、早速、ブログサイトを実装したフロントエンドのWebアプリケーションと、ブログ記事を保存するためのPostgreSQLデータベースで構成される完全なアプリケーションをデプロイしてみましょう。\nこれは、すでに構成ができていれば、Kubernetesに完全なアプリケーションをいかに早くデプロイできるかを示すためです。アプリケーション全体がデプロイされたら、フロントエンドのWebアプリケーションコンポーネントを削除し、段階的にデプロイし直すことで、どのように組み合わされているのか、どのようにKubernetesを使用しているのかを確認することができます。\nデプロイしたいアプリケーションの最初の部分は、PostgreSQLデータベースです。これをデプロイするためのリソースファイル一式は、databaseディレクトリにあります。\nls -las database/ このディレクトリ内の各ファイルには、アプリケーションコンポーネントの配置を構成するための異なるリソース定義が含まれています。\n各ファイルの定義を調べるよりも、まずはディレクトリ内のリソースをKubernetes に処理させてみましょう。これを行うには、次のように実行します。\nkubectl apply -f database/ --dry-run これで出力されるはずです。\nsecret/blog-credentials created (dry run)\rservice/blog-db created (dry run)\rpersistentvolumeclaim/blog-database created (dry run)\rdeployment.apps/blog-db created (dry run)\r 今回のkubectl applyコマンドは、設定ファイルやディレクトリに含まれるファイル群からリソースを作成するためのものです。ここでは\u0026ndash;dry-runオプションを使い、クラスタ内のオブジェクトを一切作成せずに、どのようなオブジェクトを作成するかを指示しています。また、\u0026ndash;dry-runオプションはリソースの定義を検証し、エラーがある場合は警告します。\nあるコマンドが何をするのか、どんなオプションを受け付けるのかが不明な場合は、\u0026ndash;helpオプションを付けて実行することができます。\nkubectl apply --help ドライランデプロイメントを行うことで、作成されるリソースを確認することができました。実際にデータベースコンポーネントをデプロイするために、今度は次のように実行します。\nkubectl apply -f database/ ドライランの時と同様に、kubectl applyはリソースをリストアップしますが、今回は実際にリソースが作成されます。\nsecret/blog-credentials created\rservice/blog-db created\rpersistentvolumeclaim/blog-database created\rdeployment.apps/blog-db created\r このリストの中で重要なリソースはdeployment です。deployment では、アプリケーションにデプロイするコンテナイメージの名前、起動するインスタンスの数、デプロイメントの管理方法などを指定します。\nデプロイの進捗を監視し、完了を知るには、次のコマンドを実行します。\nkubectl rollout status deployment/blog-db 引数には、リソースのタイプとこのインスタンスの名前を含む、リソースのフルネームを指定します。この場合、インスタンスはblog-dbという名前でした。\nデータベースがデプロイされたので、今度はフロントエンドのWebアプリケーションを次のように実行してデプロイします。\nkubectl apply -f frontend/ 出力は以下のようになるはずです。\npersistentvolumeclaim/blog-media created\rdeployment.apps/blog created\rservice/blog created\ringress.extensions/blog created\r 以下を実行して監視し、デプロイが完了するのを待ちます。\nkubectl rollout status deployment/blog デプロイしたアプリケーションへのアクセス #  フロントエンドのWebアプリケーション用にingressオブジェクトが作成されていることに注目してください。このオブジェクトは、アクセス可能なURLを払い出し、Webアプリケーションへのアクセスを設定します。\nこの例では、WebアプリケーションにアクセスするためのURLは次のようになります。\nNS=$(kubectl config view -o jsonpath=\u0026#39;{.contexts[].context.namespace}\u0026#39;) http://${NS}.tdc-reg-prod-d66138e.tanzu-labs.esp.vmware.com {{hint info}} 1つ目のコマンドはこの環境で払い出されるURL 名の一部を取得しています。 {{/hint}}\nこのリンクをクリックして、フロントエンドのWebアプリケーションにアクセスします。利用できないと表示された場合は、利用できるようになるまでページを更新してください。これは、Ingress の設定に時間がかかる場合があるためです。\nまだ、ブログ記事は表示されません。データベースの設定と入力については後ほど説明します。\nKubernetesクラスタのWebコンソールを使用すると、どのリソースが作成されているか、またそれらのリソース間の関係をブラウザで視覚的に表示することができますが、ほとんどの開発者はkubectlを使用してコマンドラインからKubernetesクラスタを操作します。\n現在の名前空間にある、すでに作成されたすべてのデプロイメントの一覧を表示するには、次のように実行します。\nkubectl get deployment 出力は以下のようになるはずです。\nNAME READY UP-TO-DATE AVAILABLE AGE\rblog 2/2 2 2 5m\rblog-db 1/1 1 1 5m\r 特定のリソースに絞り込みたい場合は、コマンドにそのリソース名を加えることができます。\nkubectl get deployment/blog これで、1つのリソースだけの出力が得られるはずです。もしくは、以下のように実行することもできます。\nkubectl get deployment blog 出力の最初の部分は以下のようになるはずです。\nName: blog\rNamespace: lab-k8s-fundamentals-user1\rCreationTimestamp: Tue, 04 Feb 2020 03:06:56 +0000\rLabels: app=blog\rAnnotations: deployment.kubernetes.io/revision: 1\rSelector: app=blog\rReplicas: 2 desired | 2 updated | 2 total | 2 available | 0 unavailable\rStrategyType: RollingUpdate\rMinReadySeconds: 0\rRollingUpdateStrategy: 25% max unavailable, 25% max surge\rPod Template:\r....\r これは比較的読みやすい形式にしたものであり、生のリソース定義を見るには、kubectl getの-o yaml表示出力オプションを使います。\nkubectl get deployment/blog -o yaml また、YAMLではなくJSONで作業をしたい場合には以下を実行します。\nkubectl get deployment/blog -o json "},{"id":5,"href":"/k8s-workshop/docs/kubernetes/","title":"Kubernetes ハンズオン","section":"Docs","content":"ハンズオン概要 #  KubernetesのWebサイトでは、Kubernetesを次のように説明しています。\n コンテナ化されたアプリケーションのデプロイ、スケーリング、管理を自動化するためのオープンソースのシステムです。\n このワークショップでは、Kubernetesの使い方を簡単に体験していただくことを目的としています。その過程で、Kubernetesにアプリケーションをデプロイする際の基本的なコンセプトについて学びます。このワークショップでは、開発者がKubernetesを使用するために必要な知識に焦点を当てます。これは、Kubernetesプラットフォームの運用方法に関するワークショップではありません。\n使用するラボ #  "},{"id":6,"href":"/k8s-workshop/docs/container/network/","title":"Web サーバーの公開","section":"コンテナハンズオン","content":"ネットワークサービス #  これまでに実行したすべてのコンテナは、実行元のターミナルに接続されたままでした。コンテナからの出力はターミナルに表示され、コンテナを停止したときに初めてコマンドプロンプトが戻ってきます。\nコンテナ内で実行される長時間稼働のネットワークサービスは、ターミナルから切り離してバックグラウンドプロセスとして実行する必要があります。\nbusyboxイメージを使用してWebサーバーを実行するには、次のように実行します。\ndocker run --rm -d --name httpd -p 8080:80 busybox httpd -f -vv docker runに-dオプションを付けると、コンテナがターミナルから切り離されてバックグラウンドで実行されます。\nこのコンテナをより簡単に識別して操作できるように、\u0026ndash;nameオプションを使ってhttpdという名前をつけます。\nWebサーバはネットワークサービスなので、公開するネットワークポートを指定する必要があります。これには-pオプションを使用します。\n最後に、コンテナ内で実行するコマンドとして、httpd -f -vvを使用します。\nhttpdの-fオプションは、ウェブサーバがコンテナのコンテキスト内でフォアグラウンドプロセスとして実行されるようにします。これが行われないと、コンテナはすぐに終了してしまいます。vv は詳細なロギングを可能にします。\nコンテナが稼働していることを確認するには、次のように実行します。\ndocker ps コンテナからの出力を尾行するには、次のように実行します。\ndocker logs -f httpd コンテナIDの代わりに、コンテナに割り当てたhttpd名を使用します。f オプションは、ログファイルを継続的にテーリングすることを意味します。\n初期状態ではログが出力されていませんが、次のように実行して、Webサーバに対してWebリクエストを行ってください。\ncurl localhost:8080 を実行すると、リクエストの詳細がログに記録されるはずです。\nこのケースでは、提供すべきファイルを提供していないため、Webサーバからエラーが発生しています。\nコンテナがターミナルから切り離されたので、コンテナを停止するには以下を実行する必要があります。\ndocker stop --time 2 httpd 演習 #  busybox ではなくnginx イメージを使って、コンテナでWeb サーバーをバックグラウンドで実行してみてください。また、curl で接続して、応答が返ってくることを確認しましょう。次に、nginx のログを出力してみて、実際にアクセスがあったことを確かめてみてください。最後に、実行したコンテナを停止し、削除をしてください。\n解答 初めてnginx を実行する際はイメージキャッシュが保存されていないため、自動的にレジストリからダウンロードされます。\ndocker run --rm -d --name nginx -p 8080:80 nginx 割り当てたポートに対してcurl を実行してみましょう。\ncurl localhost:8080 以下のように、\u0026ldquo;Welcome to nginx!\u0026rdquo; と表示されたらOK です。\n[~/exercises] $ curl localhost:8080 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アクセスログも見てみましょう。\ndocker logs -f nginx 自身のIP アドレス（ここでは172.17.0.1）からHTTP GET リクエストが実行されていることが分かりますね。\n172.17.0.1 - - [17/Nov/2021:12:17:15 +0000] \u0026#34;GET / HTTP/1.1\u0026#34; 200 615 \u0026#34;-\u0026#34; \u0026#34;curl/7.66.0\u0026#34; \u0026#34;-\u0026#34; 最後にコンテナを削除します。起動時に\u0026ndash;rm オプションを付けたので、docker stop で自動的に削除されます。\ndocker stop nginx    "},{"id":7,"href":"/k8s-workshop/docs/container/image/","title":"イメージ","section":"コンテナハンズオン","content":"イメージとは #  コンテナイメージから実行中のコンテナを作成しました。使用したコンテナイメージは、イメージレジストリから取得したものです。一般的に使用されているソフトウェアアプリケーション用のコンテナイメージは数多くありますが、自分のアプリケーション用にコンテナイメージを作成することの方が多いでしょう。\nコンテナイメージとは、アプリケーションを配布するためのパッケージメカニズムであり、アプリケーションの実行に必要なアプリケーションソフトウェア、オペレーティングシステムファイル、ライブラリ、その他のソフトウェアを含んでいると説明しました。\nその意味では、コンテナイメージは、ファイルシステムを構成するために解凍されるtarballやzipファイルのようなものだと言えます。しかし、それよりも少し複雑です。\nコンテナイメージは、すべての必要なファイルを含む単一のパッケージではなく、パッケージの集合体であり、それぞれがコンテナイメージの1つのレイヤーのファイルを含んでいます。\nコンテナイメージのレイヤー\n各コンテナイメージは、まずベースレイヤーから始まります。ベースレイヤーには、通常、ベースとなるOSファイル、アプリケーション、ライブラリがすべて含まれています。\nその上にさらにレイヤーを追加していきます。各レイヤーでは、ファイルを追加したり、既存のファイルを変更したり、ファイルを削除したりします。\n既存のファイルを修正したり削除したりする場合、変更されるのは下位レイヤーのオリジナルファイルではありません。修正の場合は、変更を加えたファイルの新しいコピーが新しいレイヤーに存在し、下のレイヤーのオリジナルはそのまま存在します。ファイルの削除の場合は、そのレイヤーでファイルが削除されたことがレイヤーのメタデータに記録され、オリジナルは下のレイヤーに残っています。\nこのように変更や削除が行われるのは、各レイヤーが不変であるためです。変更を加えるには、新しいレイヤーを作成するしかありません。\nコンテナイメージを使用してコンテナを作成する場合は、コンテナイメージの各レイヤーを重ね合わせてレイヤーを合成して表示する特殊なファイルシステムが使用されます。\n読み取り専用ファイルシステム\nこの最終的なコンポジットビューは、それ自体が読み取り専用である。コンテナ内のファイルに加えられた変更は、コンテナの寿命まで存在する別のレイヤに存在することになる。\nコンテナのイメージフォーマットの実際の仕様は、OCI Image Format Specification で定義されています。また、コンテナ内でアプリケーションを実行するために、イメージをどのようにアンパックし、解釈し、使用するかは、OCI Runtime Specificationで定義されています。どちらの仕様も、Linux FoundationがスポンサーとなっているOpen Container Initiative のガバナンスの下で管理されています。\nイメージのビルド #  コンテナイメージを構築するには、主に3つの方法があります。\n  既存のイメージを使ってコンテナを起動し、コンテナに変更を加え、その結果を新しいコンテナイメージとして保存することで、インタラクティブにイメージを構築する方法。\n  入力ファイルに記述されたスクリプトを使って、バッチプロセスでコンテナイメージを作成する。典型的な例としては、Dockerfileを使用してコンテナイメージを作成することが挙げられる。\n  tarballからファイルシステムのコピーをインポートしてコンテナイメージを作成する。\n  このワークショップでは、典型的な手法である2 つめのDockerfile を用いた方法を見ていきます。\nDockerfile #  ~/greeting-v1 に移動します。\ncd ~/exercises/greeting-v1 Dockerfileは、新しいコンテナイメージを作成するベースイメージの詳細と、それを作成するための手順を定義しています。Dockerfile の内容を表示します。\ncat Dockerfile FROMbusybox:latestCOPY hello goodbye /CMD [ \u0026#34;/hello\u0026#34; ]DockerfileのFROM命令は、ベースイメージの名前を指定します。\nCOPY命令は、ローカルディレクトリからイメージにファイルをコピーするために使用されます。\nCMD命令は、コンテナイメージが明示的なコマンドを指定せずに実行された場合に実行されるコマンドを設定するために使用します。\nDockerfileの命令を使ってコンテナイメージを構築するには、次のように実行します。\ndocker build -t greeting . -t でイメージの名前を指定し、\u0026quot;.\u0026quot; はDockerfile のパスを指定しています。\nコンテナイメージのレイヤーを見るには、次のように実行します。\ndocker history greeting 以下のような出力が得られるはずです。\nIMAGE CREATED CREATED BY SIZE COMMENT 0ac1216f0e3f 4 seconds ago /bin/sh -c #(nop) CMD [\u0026#34;/hello\u0026#34;] 0B aeea9801fb6a 4 seconds ago /bin/sh -c #(nop) COPY multi:03e82c91fe5fcae… 50B be5888e67be6 5 days ago /bin/sh -c #(nop) CMD [\u0026#34;sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 5 days ago /bin/sh -c #(nop) ADD file:09a89925137e1b768… 1.22MB コンテナイメージの中に、DockerfileからのCOPYとCMDの文のためのレイヤーが作成されていることがわかります。\nコンテナイメージを実行するには、次のように実行します。\ndocker run --rm greeting あるいは、別のコマンドを実行するには、次のようにします。\ndocker run --rm greeting /goodbye Dockerfileで使用できる命令の完全なリストについては、Dockerfileリファレンスをご覧ください。\nイメージの共有 #  独自のカスタムコンテナイメージを作成した後、それを別のホストシステムで実行する必要がある場合には、そのイメージを配布する方法が必要になります。\nコンテナイメージを配布する一般的な方法は、イメージレジストリにプッシュすることです。イメージレジストリにプッシュされたコンテナイメージは、他のホストにプルダウンして実行することができます。このためには、Docker Hub や Quay.io などのパブリックなイメージレジストリを使用するか、独自のプライベートなイメージレジストリを使用することができます。\nイメージをイメージレジストリにプッシュするには、まずそのイメージレジストリーにログインする必要があります。\nこのワークショップの環境では、あなたはすでにログインしている自分のプライベートイメージレジストリを持っています。もし自分でやるのであれば、docker loginコマンドを使ってイメージレジストリの場所を指定します。すると、ログイン情報の入力を求められます。\n次に、コンテナイメージにイメージレジストリの名前を組み込んだ名前をタグ付けする必要があります。\nこの時点でのイメージの名前はgreetingなので、イメージレジストリの名前を含む名前をタグ付けするには、次のように実行する必要があります。\nNS=$(kubectl config view -o jsonpath=\u0026#39;{.contexts[].context.namespace}\u0026#39;) 上記コマンドはハンズオンのセッションによって異なるレジストリの名前の一部を取得しています。  docker tag greeting:latest ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest イメージをイメージレジストリにプッシュするには、次のように実行します。\ndocker push ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest イメージレジストリへの適切なアクセス権を持つ人は、次のように実行して、イメージを別のホストでプルすることができます。\ndocker pull ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest "},{"id":8,"href":"/k8s-workshop/docs/container/summary/","title":"まとめ","section":"コンテナハンズオン","content":"まとめ #  お疲れ様でした。\n"}]