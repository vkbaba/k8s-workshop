[{"id":0,"href":"/k8s-workshop/docs/container/appendix/image-details/","title":"イメージの詳細","section":"コンテナハンズオン","content":"イメージの詳細 #  "},{"id":1,"href":"/k8s-workshop/docs/container/","title":"コンテナハンズオン","section":"Docs","content":"使用するラボ #   ワークショップの概要 #  コンテナは、OSレベルの仮想化の軽量な形態です。これにより、完全なOSを実行することなく、一連のアプリケーションプロセスを独自の分離された環境で実行することができます。\nこのワークショップでは、コンテナ・イメージを構築して実行する方法の基本を学びます。使用するツールは、dockerです。\n"},{"id":2,"href":"/k8s-workshop/docs/container/basic/","title":"基本操作","section":"コンテナハンズオン","content":"コンテナの起動 #  dockerを使ってアプリケーションをコンテナ内で起動するには、コンテナイメージが必要です。コンテナイメージは、アプリケーションを配布するためのパッケージメカニズムとして機能し、アプリケーションソフトウェア、オペレーティングシステムファイル、ライブラリ、その他アプリケーションの実行に必要なソフトウェアが含まれています。\nアプリケーション用のあらかじめ構築されたコンテナイメージや、独自のコンテナイメージを構築するためのベースとなるコンテナイメージは、イメージレジストリを使用して配布されます。\nイメージレジストリは、Docker HubとQuay.ioの2つの主要なホスト型サービスが存在します。また、GitHubやGitLabのようなGitリポジトリのホスティングサービスでも、コンテナイメージのホスティングと配布をサポートしています。\ndocker runを使ってイメージレジストリから既存のコンテナイメージをプルダウンして実行するには以下を実行します。\ndocker run docker.io/busybox:latest date アウトプットは以下のようになります。 Unable to find image \u0026#39;busybox:latest\u0026#39; locally latest: Pulling from library/busybox e2334dd9fee4: Pull complete Digest: sha256:a8cf7ff6367c2afa2a90acd081b484cbded349a7076e7bdf37a05279f276bc12 Status: Downloaded newer image for busybox:latest Mon Apr 20 00:11:37 UTC 2020\nこのコマンドは、イメージをローカル環境にプルダウンするために行われた手順の詳細をログに記録します。この処理が完了すると、コンテナイメージからコンテナが起動され、コマンドラインで指定されたdateコマンドがコンテナ内で実行されます。dateコマンドはすぐに終了するので、コンテナはそのままシャットダウンされます。\n今回使用したコンテナイメージは、busyboxというものです。これは、非常にミニマルなUnixライクのコンテナイメージです。最新バージョンのコンテナイメージを使用し、Docker Hubのイメージレジストリ（docker.io）から取得するように指定しました。\nこのコマンドをもう1回実行してみてください。 docker run docker.io/busybox:latest date\ndateコマンドがすぐに実行され、コンテナイメージを最初にプルダウンする必要があるという詳細情報は記録されないことがわかります。これは、コンテナイメージがローカル環境にキャッシュされ、次回以降の実行時に使用されるからです。\nどのようなコンテナイメージがローカル環境にプルダウンされたかは、次のように実行することで確認できます。\ndocker images アウトプットは以下のようになります。\nREPOSITORY TAG IMAGE ID CREATED SIZE busybox latest be5888e67be6 5 days ago 1.22MB 必要であれば、docker runはコンテナイメージを最初に必要とされるときにプルダウンします。実行される前にイメージをプルダウンしたい場合は、docker pullコマンドを使用することができます。\ndocker pull docker.io/busybox:latest ターミナルの操作 #  先ほどはBusybox コンテナイメージから起動したコンテナ内で date コマンドを実行しました。コンテナイメージに含まれている任意のアプリケーションを実行することができます。\nコンテナを作成して、その中でコマンドを実行するために対話したい場合は、対話型シェルを実行します。\ndocker run -it busybox sh 対話型端末を必要とするコマンドを実行する場合は、docker runに-itオプションを指定する必要があります。これにより、ターミナルが確保され、stdinが入力可能な状態に保たれます。 ★ 補足\nまた、今回はコンテナイメージの名前をbusyboxと略しています。バージョンタグが指定されていない場合は latest が使用されます。イメージレジストリのホストが指定されていない場合は、dockerのグローバル設定で定義されているデフォルトのイメージレジストリが検索されます。すでにDocker Hubからbusybox:latestのイメージを取り出しているので、それがマッチします。\nコンテナ内で実行されているプロセスの一覧を見るには、次のように実行します。 ps\n以下のような出力が表示されるはずです。 pid user time command 1 root 0:00 sh 8 root 0:00 ps\nコンテナのコンテキスト内で起動したプロセスのみが表示されます。下層のコンテナホスト（例えばコンテナを実行している仮想マシン）で実行されているプロセスは表示されません。\n実行中のコンテナの一覧を表示するには、コンテナホスト上で実行します。\ndocker ps 上記で起動したコンテナが対話型シェルで実行されているのが確認できるはずです。\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae576793e3e9 busybox \u0026#34;sh\u0026#34; 32 seconds ago Up 31 seconds recursing_leavitt コンテナホストから既存のコンテナにアクセスし、その中でコマンドを実行するには、docker execコマンドを使用します。docker runと同様に、インタラクティブターミナルを必要とするコマンドを実行する場合は、-itオプションを使用します。\ndocker execを実行する際には、アクセスしたいコンテナのIDを指定する必要があります。最後に起動したコンテナのコンテナIDを表示するには、次のコマンドを実行します。 docker ps -ql\n既存のコンテナ内で動作する2つ目の対話型端末を作成するには、次のように実行します。\ndocker exec -it `docker ps -ql` sh 元の対話型端末で再度 ps を実行します。 ps\nこれで、2つのシェルプロセスが実行されていることが確認できます。\n1つ目の対話型ターミナルで次のように実行して終了します。\nexit このプロセスはコンテナ内で実行されているメインプロセスであり、プロセスIDは1であるため、コンテナがシャットダウンされ、2つ目の対話型端末のセッションも閉じられます。\nコンテナの停止 #  コンテナがシャットダウンされると、アプリケーションプロセスはなくなりますが、コンテナの状態のコピーは保持されます。停止したコンテナを含むすべてのコンテナの一覧は、次のように実行することで確認できます。\ndocker ps -a いくつものコンテナを起動しているので、停止しているコンテナが複数表示されているはずです。\nONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae576793e3e9 busybox \u0026#34;sh\u0026#34; About a minute ago Exited (0) 16 seconds ago recursing_leavitt e894e7d5790f busybox:latest \u0026#34;date\u0026#34; 3 minutes ago Exited (0) 3 minutes ago heuristic_bassi 9d1706a4b51f busybox:latest \u0026#34;date\u0026#34; 3 minutes ago Exited (0) 3 minutes ago inspiring_banzai コンテナを実行するときは、フォアグラウンドで実行し、コンテナからの出力はすべてターミナルに表示されました。\nまた、コンテナからの出力はログファイルにも取り込まれました。コンテナIDを引数にしてdocker logsコマンドを実行すると、実行中または停止中のコンテナのログファイルを見ることができます。\ndocker logs `docker ps -ql` コンテナのログファイルに加えて、コンテナ内からファイルシステムに加えられた変更のコピーも保存されるため、停止中のコンテナからファイルをコピーしたり、停止中のコンテナから新しいコンテナイメージを作成したりすることもできます。\n停止したコンテナにはいくつかの用途がありますが、スペースを消費しますので、停止したコンテナを削除することが重要です。そうしないと、最終的にはディスクスペースが足りなくなってしまいます。\n停止したコンテナを1つだけ削除するには、コンテナIDを引数にしてdocker rmを使用します。\ndocker rm `docker ps -ql` これで、停止していた2つのコンテナだけが残るはずです。\ndocker ps -a 停止しているコンテナをすべて削除するには、次のように実行します。\ndocker rm $(docker ps -aq) docker ps -aは停止中のコンテナだけでなく、稼働中のコンテナも反応しますが、docker rmコマンドは停止中のコンテナのみを削除します。\nこれでコンテナは残っていないはずです。\ndocker ps -aを実行します。 停止したコンテナをシャットダウンした後に操作する必要がないことがわかっている場合は、docker runの実行時に\u0026ndash;rmオプションを使用できます。\ndocker run --rm busybox date このオプションを使用すると、停止したコンテナは自動的に削除されます。\ndocker ps -a "},{"id":3,"href":"/k8s-workshop/docs/container/network/","title":"Web サーバーの公開","section":"コンテナハンズオン","content":"ネットワークサービス #  これまでに実行したすべてのコンテナは、実行元のターミナルに接続されたままでした。コンテナからの出力はターミナルに表示され、コンテナを停止したときに初めてコマンドプロンプトが戻ってきます。\nコンテナ内で実行される長時間稼働のネットワークサービスは、ターミナルから切り離してバックグラウンドプロセスとして実行する必要があります。\nbusyboxイメージを使用してWebサーバーを実行するには、次のように実行します。\ndocker run --rm -d --name httpd -p 8080:80 busybox httpd -f -vv docker runに-dオプションを付けると、コンテナがターミナルから切り離されてバックグラウンドで実行されます。\nこのコンテナをより簡単に識別して操作できるように、\u0026ndash;nameオプションを使ってhttpdという名前をつけます。\nWebサーバはネットワークサービスなので、公開するネットワークポートを指定する必要があります。これには-pオプションを使用します。\n最後に、コンテナ内で実行するコマンドとして、httpd -f -vvを使用します。\nhttpdの-fオプションは、ウェブサーバがコンテナのコンテキスト内でフォアグラウンドプロセスとして実行されるようにします。これが行われないと、コンテナはすぐに終了してしまいます。vv は詳細なロギングを可能にします。\nコンテナが稼働していることを確認するには、次のように実行します。\ndocker ps コンテナからの出力を尾行するには、次のように実行します。\ndocker logs -f httpd コンテナIDの代わりに、コンテナに割り当てたhttpd名を使用します。f オプションは、ログファイルを継続的にテーリングすることを意味します。\n初期状態ではログが出力されていませんが、次のように実行して、Webサーバに対してWebリクエストを行ってください。\ncurl localhost:8080 を実行すると、リクエストの詳細がログに記録されるはずです。\nこのケースでは、提供すべきファイルを提供していないため、Webサーバからエラーが発生しています。\nコンテナがターミナルから切り離されたので、コンテナを停止するには以下を実行する必要があります。\ndocker stop --time 2 httpd 演習 #  busybox ではなくnginx イメージを使って、コンテナでWeb サーバーをバックグラウンドで実行してみてください。また、curl で接続して、応答が返ってくることを確認しましょう。次に、nginx のログを出力してみて、実際にアクセスがあったことを確かめてみてください。最後に、実行したコンテナを停止し、削除をしてください。\n解答 初めてnginx を実行する際はイメージキャッシュが保存されていないため、自動的にレジストリからダウンロードされます。\ndocker run --rm -d --name nginx -p 8080:80 nginx 割り当てたポートに対してcurl を実行してみましょう。\ncurl localhost:8080 以下のように、\u0026ldquo;Welcome to nginx!\u0026rdquo; と表示されたらOK です。\n[~/exercises] $ curl localhost:8080 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; アクセスログも見てみましょう。\ndocker logs -f nginx 自身のIP アドレス（ここでは172.17.0.1）からHTTP GET リクエストが実行されていることが分かりますね。\n172.17.0.1 - - [17/Nov/2021:12:17:15 +0000] \u0026#34;GET / HTTP/1.1\u0026#34; 200 615 \u0026#34;-\u0026#34; \u0026#34;curl/7.66.0\u0026#34; \u0026#34;-\u0026#34; 最後にコンテナを削除します。起動時に\u0026ndash;rm オプションを付けたので、docker stop で自動的に削除されます。\ndocker stop nginx    "},{"id":4,"href":"/k8s-workshop/docs/container/image/","title":"イメージ","section":"コンテナハンズオン","content":"イメージとは #  コンテナイメージから実行中のコンテナを作成しました。使用したコンテナイメージは、イメージレジストリから取得したものです。一般的に使用されているソフトウェアアプリケーション用のコンテナイメージは数多くありますが、自分のアプリケーション用にコンテナイメージを作成することの方が多いでしょう。\nコンテナイメージとは、アプリケーションを配布するためのパッケージメカニズムであり、アプリケーションの実行に必要なアプリケーションソフトウェア、オペレーティングシステムファイル、ライブラリ、その他のソフトウェアを含んでいると説明しました。\nその意味では、コンテナイメージは、ファイルシステムを構成するために解凍されるtarballやzipファイルのようなものだと言えます。しかし、それよりも少し複雑です。\nコンテナイメージは、すべての必要なファイルを含む単一のパッケージではなく、パッケージの集合体であり、それぞれがコンテナイメージの1つのレイヤーのファイルを含んでいます。\nコンテナイメージのレイヤー\n各コンテナイメージは、まずベースレイヤーから始まります。ベースレイヤーには、通常、ベースとなるOSファイル、アプリケーション、ライブラリがすべて含まれています。\nその上にさらにレイヤーを追加していきます。各レイヤーでは、ファイルを追加したり、既存のファイルを変更したり、ファイルを削除したりします。\n既存のファイルを修正したり削除したりする場合、変更されるのは下位レイヤーのオリジナルファイルではありません。修正の場合は、変更を加えたファイルの新しいコピーが新しいレイヤーに存在し、下のレイヤーのオリジナルはそのまま存在します。ファイルの削除の場合は、そのレイヤーでファイルが削除されたことがレイヤーのメタデータに記録され、オリジナルは下のレイヤーに残っています。\nこのように変更や削除が行われるのは、各レイヤーが不変であるためです。変更を加えるには、新しいレイヤーを作成するしかありません。\nコンテナイメージを使用してコンテナを作成する場合は、コンテナイメージの各レイヤーを重ね合わせてレイヤーを合成して表示する特殊なファイルシステムが使用されます。\n読み取り専用ファイルシステム\nこの最終的なコンポジットビューは、それ自体が読み取り専用である。コンテナ内のファイルに加えられた変更は、コンテナの寿命まで存在する別のレイヤに存在することになる。\nコンテナのイメージフォーマットの実際の仕様は、OCI Image Format Specification で定義されています。また、コンテナ内でアプリケーションを実行するために、イメージをどのようにアンパックし、解釈し、使用するかは、OCI Runtime Specificationで定義されています。どちらの仕様も、Linux FoundationがスポンサーとなっているOpen Container Initiative のガバナンスの下で管理されています。\nイメージのビルド #  コンテナイメージを構築するには、主に3つの方法があります。\n  既存のイメージを使ってコンテナを起動し、コンテナに変更を加え、その結果を新しいコンテナイメージとして保存することで、インタラクティブにイメージを構築する方法。\n  入力ファイルに記述されたスクリプトを使って、バッチプロセスでコンテナイメージを作成する。典型的な例としては、Dockerfileを使用してコンテナイメージを作成することが挙げられる。\n  tarballからファイルシステムのコピーをインポートしてコンテナイメージを作成する。\n  このワークショップでは、典型的な手法である2 つめのDockerfile を用いた方法を見ていきます。\nDockerfile #  ~/greeting-v1 に移動します。\ncd ~/exercises/greeting-v1 Dockerfileは、新しいコンテナイメージを作成するベースイメージの詳細と、それを作成するための手順を定義しています。Dockerfile の内容を表示します。\ncat Dockerfile FROMbusybox:latestCOPY hello goodbye /CMD [ \u0026#34;/hello\u0026#34; ]DockerfileのFROM命令は、ベースイメージの名前を指定します。\nCOPY命令は、ローカルディレクトリからイメージにファイルをコピーするために使用されます。\nCMD命令は、コンテナイメージが明示的なコマンドを指定せずに実行された場合に実行されるコマンドを設定するために使用します。\nDockerfileの命令を使ってコンテナイメージを構築するには、次のように実行します。\ndocker build -t greeting . -t でイメージの名前を指定し、\u0026quot;.\u0026quot; はDockerfile のパスを指定しています。\nコンテナイメージのレイヤーを見るには、次のように実行します。\ndocker history greeting 以下のような出力が得られるはずです。\nIMAGE CREATED CREATED BY SIZE COMMENT 0ac1216f0e3f 4 seconds ago /bin/sh -c #(nop) CMD [\u0026#34;/hello\u0026#34;] 0B aeea9801fb6a 4 seconds ago /bin/sh -c #(nop) COPY multi:03e82c91fe5fcae… 50B be5888e67be6 5 days ago /bin/sh -c #(nop) CMD [\u0026#34;sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 5 days ago /bin/sh -c #(nop) ADD file:09a89925137e1b768… 1.22MB コンテナイメージの中に、DockerfileからのCOPYとCMDの文のためのレイヤーが作成されていることがわかります。\nコンテナイメージを実行するには、次のように実行します。\ndocker run --rm greeting あるいは、別のコマンドを実行するには、次のようにします。\ndocker run --rm greeting /goodbye Dockerfileで使用できる命令の完全なリストについては、Dockerfileリファレンスをご覧ください。\nイメージの共有 #  独自のカスタムコンテナイメージを作成した後、それを別のホストシステムで実行する必要がある場合には、そのイメージを配布する方法が必要になります。\nコンテナイメージを配布する一般的な方法は、イメージレジストリにプッシュすることです。イメージレジストリにプッシュされたコンテナイメージは、他のホストにプルダウンして実行することができます。このためには、Docker Hub や Quay.io などのパブリックなイメージレジストリを使用するか、独自のプライベートなイメージレジストリを使用することができます。\nイメージをイメージレジストリにプッシュするには、まずそのイメージレジストリーにログインする必要があります。\nこのワークショップの環境では、あなたはすでにログインしている自分のプライベートイメージレジストリを持っています。もし自分でやるのであれば、docker loginコマンドを使ってイメージレジストリの場所を指定します。すると、ログイン情報の入力を求められます。\n次に、コンテナイメージにイメージレジストリの名前を組み込んだ名前をタグ付けする必要があります。\nこの時点でのイメージの名前はgreetingなので、イメージレジストリの名前を含む名前をタグ付けするには、次のように実行する必要があります。\nNS=kubectl config view -o jsonpath=\u0026#39;{.contexts[].context.namespace}\u0026#39; 上記コマンドはハンズオンのセッションによって異なるレジストリの名前の一部を取得しています。  docker tag greeting:latest ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest イメージをイメージレジストリにプッシュするには、次のように実行します。\ndocker push ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest イメージレジストリへの適切なアクセス権を持つ人は、次のように実行して、イメージを別のホストでプルすることができます。\ndocker pull ${NS}-registry.tdc-priv-prod-1e19974.tanzu-labs.esp.vmware.com/greeting:latest "},{"id":5,"href":"/k8s-workshop/docs/container/summary/","title":"まとめ","section":"コンテナハンズオン","content":"まとめ #  お疲れ様でした。\n"}]